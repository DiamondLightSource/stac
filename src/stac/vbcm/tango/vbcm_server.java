//+============================================================================
// $Source: /utils/volumes/instrxtaldev/cvsroot/STAC/gui/stacgui/src/stacgui/vbcm/tango/vbcm_server.java,v $
//
// project :     Tango Device Server
//
// Description:	java source code for the MicroDiff class and its commands.
//              This class is derived from DeviceImpl class.
//              It represents the CORBA servant obbject which
//              will be accessed from the network. All commands which
//              can be executed on the MicroDiff are implemented
//              in this file.
//
// $Author: sudol $
//
// $Revision: 1.1 $
//
// $Log: vbcm_server.java,v $
// Revision 1.1  2007/09/13 16:10:02  sudol
// new vbcm which comes with a tango server on top
//
//
// copyleft :   European Synchrotron Radiation Facility
//              BP 220, Grenoble 38043
//              FRANCE
//
//-============================================================================
//
//  		This file is generated by POGO
//	(Program Obviously used to Generate tango Object)
//
//         (c) - Software Engineering Group - ESRF
//=============================================================================


package stac.vbcm.tango;


import stac.core.*;
import stac.vbcm.*;

import java.io.File;
import java.util.*;
import org.omg.CORBA.*;

import fr.esrf.Tango.*;
import fr.esrf.TangoDs.*;
import fr.esrf.TangoApi.*;


/**
 *	Class Description:
 *	High level control
 *
 * @author	$Author: sudol $
 * @version	$Revision: 1.1 $
 */

//--------- Start of States Description ----------
/*
 *	Device States Description:
 *  DevState.FAULT :    A hardware or software error occured. User intervention is required to acknowledge
 *                      the error or to restart the application
 *  DevState.MOVING :   The application is busy and cannot accept commands
 *                      The processing of a command is pending (e.g. a scan is programmed,
 *                      a motor is moving or data are processed )
 *  DevState.ALARM :    A hardware or software warning occured. The application will recover properly.
 *                      Another command will reset this alarm state
 *  DevState.STANDBY :  The application is ready
 *  DevState.DISABLE :  The application has disabled remote control. No command accepted
 *  DevState.OFF :      The MicroDiffractometer application is not running.
 *  DevState.INIT :     The MicroDiffractometer is initialising or closing.
 */
//--------- End of States Description ----------


public class vbcm_server extends DeviceImpl implements TangoConst
{
	
	static vBCM vbcm = null;
	
	double CenterNeedleRadius = -100; //unsuccessfull centering
	
	String STATUSOK="STANDBY";
	String STATUSMOVE="MOVING";
	
	int requestCt=0;

	synchronized void addReq () {
		requestCt++;
	}
	synchronized void delReq () {
		if (requestCt>0)
			requestCt--;
	}
	synchronized int numReq () {
		return requestCt;
	}
	
	protected	int	state;

	//--------- Start of attributes data members ----------

//	protected double[]	attr_Omega_read = new double[1];
//	protected double	attr_Omega_write;
//	protected double[]	attr_Kappa_read = new double[1];
//	protected double	attr_Kappa_write;
//	protected double[]	attr_Phi_read = new double[1];
//	protected double	attr_Phi_write;
//	protected double[]	attr_X_read = new double[1];
//	protected double	attr_X_write;
//	protected double[]	attr_Y_read = new double[1];
//	protected double	attr_Y_write;
//	protected double[]	attr_Z_read = new double[1];
//	protected double	attr_Z_write;

//--------- End of attributes data members ----------


	//--------- Start of properties data members ----------

	//--------- End of properties data members ----------


	//	Add your own data members here
	//--------------------------------------



//=========================================================
/**
 *	Constructor for simulated Time Device Server.
 *
 *	@param	cl	The DeviceClass object
 *	@param	s	The Device name.
 */
//=========================================================
	vbcm_server(DeviceClass cl, String s) throws DevFailed
	{
		super(cl,s);
		init_device();
	}
//=========================================================
/**
 *	Constructor for simulated Time Device Server.
 *
 *	@param	cl	The DeviceClass object
 *	@param	s	The Device name.
 *	@param	d	Device description.
 */
//=========================================================
	vbcm_server(DeviceClass cl, String s, String d) throws DevFailed
	{
		super(cl,s,d);
		init_device();
	}


//=========================================================
/**
 *	Initialize the device.
 */
//=========================================================
	public void init_device() throws DevFailed
	{
		System.out.println("MicroDiff() create " + device_name);

		//	Initialise variables to default values
		//-------------------------------------------
		set_state(DevState.ON);
		
		//vbcm
		String [] mlist=vbcm.getMotorList();
		
		AttributeConfig [] ac = this.get_attribute_config(mlist);
		for (int i=0;i<ac.length;i++) {
			Vector lim = vbcm.getMotorLimits(ac[i].name);
			try {
				ac[i].min_value=new Double(((Double)lim.elementAt(0))-1e-4).toString();
				ac[i].max_value=new Double(((Double)lim.elementAt(1))+1e-4).toString();
			} catch (Exception e) {
				//ac[i].min_value="0";
				//ac[i].max_value="0";				
			}
		}
		this.set_attribute_config(ac);
	}

//=========================================================
/**
 *	Method always executed before command execution.
 */
//=========================================================
	public void always_executed_hook()
	{	
		get_logger().info("In always_executed_hook method()");
	}

	public void moveMotor(String motorName,WAttribute att) {
    	ParamTable newPos=new ParamTable();
		newPos.setSingleDoubleValue(motorName,att.get_db_write_value());
    	try {
			vbcm.MoveMotors(newPos);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			//e.printStackTrace();
		}
		
	}
//===================================================================
/**
 *	Method called by the write_attributes CORBA operation to
 *	write device hardware.
 *
 *	@param	attr_list	vector of index in the attribute vector
 *		of attribute to be written
 */
//===================================================================			
	public void write_attr_hardware(Vector attr_list)
	{
		get_logger().info("In write_attr_hardware for "+attr_list.size()+" attribute(s)");
	
		for (int i=0 ; i<attr_list.size() ; i++)
		{
			WAttribute att = dev_attr.get_w_attr_by_ind(((Integer)(attr_list.elementAt(i))).intValue());
			String attr_name = att.get_name();

			//	Switch on attribute name
			//---------------------------------
			if (attr_name == "CenterNeedleRadius")
			{
				//	Add your own code here
				this.CenterNeedleRadius=att.get_db_write_value();
			}
			else //auto generated attributes
			{
				//	Add your own code here
				moveMotor(attr_name,att);
			}
		}
	}
//===================================================================
/**
 *	Method called by the read_attributes CORBA operation to
 *	read device hardware
 *
 *	@param	attr_list	Vector of index in the attribute vector
 *		of attribute to be read
 */
//===================================================================			
	public void read_attr_hardware(Vector attr_list) throws DevFailed
	{
		get_logger().info("In read_attr_hardware for "+attr_list.size()+" attribute(s)");

		for (int i=0 ; i<attr_list.size() ; i++)
		{
			WAttribute att = dev_attr.get_w_attr_by_ind(((Integer)(attr_list.elementAt(i))).intValue());
			String attr_name = att.get_name();

			//	Switch on attribute name
			//---------------------------------
			if (attr_name == "CenterNeedleRadius")
			{
				//	Add your own code here
				att.set_value(this.CenterNeedleRadius);
			}
			else //auto generated attributes
			{
				//	Add your own code here
				att.set_value(vbcm.getMotorPos(attr_name));
			}
		}

	}
//===================================================================
/**
 *	Method called by the read_attributes CORBA operation to
 *	set internal attribute value.
 *
 *	@param	attr	reference to the Attribute object
 */
//===================================================================			
	public void read_attr(Attribute attr) throws DevFailed
	{
		String attr_name = attr.get_name();
		get_logger().info("In read_attr for attribute " + attr_name);

		//	Switch on attribute name
		//---------------------------------
		if (attr_name == "")
		{
			//	Add your own code here
		}
		else //auto generated attributes 
		{
			//	Add your own code here
		}
	}



//=========================================================
/**
 *	Execute command "Reset" on device.
 *	Clear the current error and try to reset motors (stopped , loop closed
 *
 */
//=========================================================
public void reset() throws DevFailed
	{
		get_logger().info("Entering reset()");

		// ---Add your Own code to control device here ---

		get_logger().info("Exiting reset()");
	}


//=========================================================
/**
 *	Execute command "SyncMoveMotors" on device.
 *
 * @param	argin	NewPositions
 */
//=========================================================
public void sync_move_motors(DevVarDoubleStringArray argin) throws DevFailed
	{
		get_logger().info("Entering sync_move_motors()");

		// ---Add your Own code to control device here ---
    	ParamTable newPos=new ParamTable();
    	for(int i=0;i<argin.dvalue.length;i++){
    		String motorName = (String)argin.svalue[i];
    		newPos.setSingleDoubleValue(motorName,argin.dvalue[i]);
    	}
    	try {
			vbcm.MoveMotors(newPos);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			//e.printStackTrace();
		}
		

		get_logger().info("Exiting sync_move_motors()");
	}

//=========================================================
/**
 *	Execute command "CenterNeedle" on device.
 *
 * @param	argin	NewPositions
 */
//=========================================================
public boolean center_needle() throws DevFailed
	{
		get_logger().info("Entering center_needle()");

		// ---Add your Own code to control device here ---
    	try {
			vbcm.CenterNeedle();
			//set up CenterNeedleRaius as 0
			CenterNeedleRadius=0;
		} catch (Exception e) {
			// TODO Auto-generated catch block
			//e.printStackTrace();
			//set up CenterNeedleRaius as -100 (ERROR)
			CenterNeedleRadius=-100;
		}
		

		get_logger().info("Exiting center_needle()");
		return true;
	}

//=========================================================
/**
 *	Execute command "State" on device.
 *
 * @param	argin	NewPositions
 */
//=========================================================
public DevState dev_state()
	{
		get_logger().info("Entering getState()");
		
		String STATUS="";
		DevState state=super.get_state();
		
		try {
			if (numReq()>0 || vbcm.numOfActiveMotions()>0) {
				STATUS=STATUSMOVE;
				state=DevState.MOVING;
			} else {
				STATUS=STATUSOK;
				state=DevState.STANDBY;
			}
		} catch (Exception e) {
			// TODO Auto-generated catch block
			state=DevState.OFF;
		}

		get_logger().info("Exiting getState()");
		//return STATUS;
		return state;
	}

//=========================================================
/**
 *	Execute command "GetCollisionInfo" on device.
 *
 * @param	argin	NewPositions
 */
//=========================================================
public boolean get_collision_info(DevVarDoubleStringArray argin) throws DevFailed
	{
		get_logger().info("Entering get_collsion_info()");

		// ---Add your Own code to control device here ---
    	ParamTable newPos=new ParamTable();
    	for(int i=0;i<argin.dvalue.length;i++){
    		String motorName = (String)argin.svalue[i];
    		newPos.setSingleDoubleValue(motorName,argin.dvalue[i]);
    	}
    	boolean coll=false;
    	try {
    		vbcm.checkCollision(true);
			vbcm.MoveMotors(newPos);
			Thread sleep= new Thread();
			sleep.start();
			while (vbcm.numOfActiveMotions()!=0) {
				sleep.sleep(200);				
			}
			sleep.stop();
			coll=vbcm.getCollisionInfo();
			vbcm.checkCollision(false);
		} catch (Exception e) {
			// TODO Auto-generated catch block
			//e.printStackTrace();
		}
		

		get_logger().info("Exiting get_collsion_info()");
		return coll;
	}



//=========================================================
/**
 *	main part for the device server class
 */
//=========================================================
	public static void main(String[] argv)
	{
		try
		{
			//start the vBCM	vBCM vbcm = null;
			
	        if (argv.length == 0) {
	            Stac_Out.println("No file to display");
	            Stac_Out.println("Usage: java vBCM [-server] pathname | URL");
	            System.exit(0);
	        }

	        boolean serverLoad = argv[0].equals("-server");

	        if(((argv.length == 1) && serverLoad) ||
	           ((argv.length == 2) && !serverLoad)) {

	            Stac_Out.println("No file to display");
	            Stac_Out.println("Usage: java vBCM [-server] pathname | URL");
	            System.exit(0);
	        }

	        String filename = (argv.length == 1) ? argv[0] : argv[1];
			
			File cfg= new File(System.getProperty("BCMDEF"));
    		String vBCMconf=cfg.getParent()+File.separator+filename;
    		vbcm = new vBCM(""+vBCMconf,!serverLoad);
    		vbcm.activateVBCM(vbcm);
			
    		//config the tango server
    		//System.setProperty("TANGO_HOST","localhost:5925");
    		System.setProperty("OAPort","5925");
    		
			//start tango server
    		String[] serverargs = {"vBCM_server","-nodb","-dlist","vbcm/vbcm_server/general","-v5"};
    		//String[] serverargs = {"vBCM_server","-nodb","-v5"};
    		Util tg = Util.init(serverargs,"vbcm_server");
    		//if nodb we have to manually add the calss!
    		tg.add_class("stac.vbcm.tango.vbcm_server");
			tg.server_init();
			
			//vbcm.generateCCPNCollisionMap("CM_STORAGE");
			
			System.out.println("Ready to accept request\n");

			tg.server_run();			
		}

		catch (OutOfMemoryError ex)
		{
			System.err.println("Can't allocate memory !!!!");
			System.err.println("Exiting");
		}
		catch (UserException ex)
		{
			Except.print_exception(ex);
			
			System.err.println("Received a CORBA user exception");
			System.err.println("Exiting");
		}
		catch (SystemException ex)
		{
			Except.print_exception(ex);
			
			System.err.println("Received a CORBA system exception");
			System.err.println("Exiting");
		}
		
		System.exit(-1);		
	}
}
	

//--------------------------------------------------------------------------
/* end of $Source: /utils/volumes/instrxtaldev/cvsroot/STAC/gui/stacgui/src/stacgui/vbcm/tango/vbcm_server.java,v $ */
